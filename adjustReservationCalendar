function adjustReservationCalendar() {
  const currentDate = new Date();
  const oneMonthLater = new Date(new Date(currentDate).setDate(currentDate.getDate() + 30));

  // 予約枠と社長の予定を統合し、開始時刻でソート
  let allEvents = [...PRESIDENT_CALENDAR.getEvents(currentDate, oneMonthLater), ...RESERVATION_CALENDAR.getEvents(currentDate, oneMonthLater)];
  allEvents = createEventArray(allEvents).sort((a, b) => a.startTime - b.startTime);

  // 予約枠のチェックと処理
  for (let i = 0; i < allEvents.length; i++) {
    const reservationSlot = allEvents[i];

    // 削除済み、または予約枠でない場合はスキップ
    if (!reservationSlot.flag || reservationSlot.title !== "予約枠") continue;

    // 予約枠と他のイベントの重複を確認
    if (allEvents.some((event, idx) => idx !== i && event.flag && isTimeOverlapping(reservationSlot, event))) {
      reservationSlot.flag = false; // 重複していれば削除対象とする
      continue;
    }

    // 前後20分以内かつ「予約枠」以外の前後のイベントを取得
    const { previous, next } = getNearbyEvents(allEvents, i, 20);

    // 周囲の20分以内のイベントをチェックし、場所設定または削除を行う
    if (!determineLocationFromSurroundingEvents(reservationSlot, previous, next)) {
      reservationSlot.flag = false; // 挟み撃ち判定で削除対象とする
    }
  }

  // 削除フラグが立っている予約枠を削除
  for (let event of allEvents) {
    if (!event.flag && event.title === "予約枠") {
      RESERVATION_CALENDAR.getEventById(event.id).deleteEvent();
    }
  }
}

/**
 * イベントオブジェクトを配列に変換し、flagプロパティをデフォルトでtrueに設定
 * @param {Array} events - イベントのリスト
 * @returns {Array} - イベントオブジェクトの配列
 */
function createEventArray(events) {
  return events.map(event => ({
    id: event.getId(),
    title: event.getTitle(),
    start: event.getStartTime(),
    startTime: event.getStartTime().getTime(),
    end: event.getEndTime(),
    endTime: event.getEndTime().getTime(),
    location: event.getLocation(),
    flag: true, // デフォルトでtrueに設定
  }));
}

/**
 * 前後の「予約枠以外の予定」を取得
 * @param {Array} allEvents - ソート済みのイベント配列
 * @param {number} index - チェック対象のインデックス
 * @param {number} minutes - 前後の時間範囲（分単位）
 * @returns {Object} - 前の予定と次の予定を含むオブジェクト { previous: 前の予定, next: 次の予定 }
 */
function getNearbyEvents(allEvents, index, minutes) {
  const rangeMillis = minutes * 60 * 1000;
  let previousEvent = {location:null};
  let nextEvent = {location:null};

  // 前の予定を探索
  for (let i = index - 1; i >= 0; i--) {
    const event = allEvents[i];
    // 現在のイベントの20分範囲外ならbreak
    if (allEvents[index].startTime - event.endTime > rangeMillis) {
      break;
    }
    if (event.flag && event.title !== "予約枠") {
      previousEvent = event;
      break;
    }
  }

  // 次の予定を探索
  for (let i = index + 1; i < allEvents.length; i++) {
    const event = allEvents[i];
    // 現在のイベントの20分範囲外ならbreak
    if (event.startTime - allEvents[index].endTime > rangeMillis) {
      break;
    }
    if (event.flag && event.title !== "予約枠") {
      nextEvent = event;
      break;
    }
  }

  return { previous: previousEvent, next: nextEvent };
}


/**
 * 前後のイベントに基づき、予約枠の場所を設定または削除
 * @param {Object} targetSlot - チェック対象の予約枠
 * @param {Object} previous - 前の予定のオブジェクト（場所がある場合のみ）
 * @param {Object} next - 次の予定のオブジェクト（場所がある場合のみ）
 * @returns {boolean} - 場所が設定または削除に成功したか
 */
function determineLocationFromSurroundingEvents(targetSlot, previous, next) {
  // previousとnextのどちらにも場所が入っている
  if (previous.location && next.location) {
    // 1. previousとnextが異なる場所の場合、targetSlotを削除
    if (previous.location !== next.location) {
      return false;
    }

    // 2. previousとnextに同じ場所の場合、targetSlotを同じ場所に固定
    if (previous.location === next.location) {
      const targetEvent = RESERVATION_CALENDAR.getEventById(targetSlot.id);
      targetEvent.setLocation(previous.location);
      targetSlot.location = previous.location;
      return true;
    }
  }

  // 3. 前または後の場所がnullで、もう片方に場所が入っている場合、その場所に従う
  if (previous.location) {
    const targetEvent = RESERVATION_CALENDAR.getEventById(targetSlot.id);
    targetEvent.setLocation(previous.location);
    targetSlot.location = previous.location;
    return true;
  }

  if (next.location) {
    const targetEvent = RESERVATION_CALENDAR.getEventById(targetSlot.id);
    targetEvent.setLocation(next.location);
    targetSlot.location = next.location;
    return true;
  }

  // 4. 前後のイベントまたは場所がどちらもnullの場合、場所は自由のままでOK
  if (targetSlot.location) {
    const targetEvent = RESERVATION_CALENDAR.getEventById(targetSlot.id);
    targetEvent.setLocation(null);
    targetSlot.location = null;
    return true;
  }

  return true;
}

/**
 * 2つのイベントの時間が重なっているか確認
 * @param {Object} event1 - チェック対象のイベント1
 * @param {Object} event2 - チェック対象のイベント2
 * @returns {boolean} - 重複している場合はtrue
 */
function isTimeOverlapping(event1, event2) {
  return event1.startTime < event2.endTime && event1.endTime > event2.startTime;
}
